{"meta":{"title":"桂仁沛的小世界","subtitle":"One Page","description":"One Page","author":"徐腾峰","url":"http://blog.xutengfeng.com"},"pages":[{"title":"分类","date":"2017-11-26T12:22:43.000Z","updated":"2017-11-26T12:45:56.928Z","comments":false,"path":"categories/index.html","permalink":"http://blog.xutengfeng.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-26T12:24:31.000Z","updated":"2017-11-26T13:11:15.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.xutengfeng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bind() to 0.0.0.0:80 failed (98: Address already in use)","slug":"bind-to-0-0-0-0-80-failed-98-Address-already-in-use","date":"2019-02-17T10:29:53.000Z","updated":"2019-02-17T10:39:23.712Z","comments":true,"path":"2019/02/17/bind-to-0-0-0-0-80-failed-98-Address-already-in-use/","link":"","permalink":"http://blog.xutengfeng.com/2019/02/17/bind-to-0-0-0-0-80-failed-98-Address-already-in-use/","excerpt":"","text":"前提背景在一次重启服务器的时候，nginx报了错，说80端口被占用了~~。然后试了一下，通过域名绑定不上了。我一个前端是整不出什么玩意儿了，于是就上网查了查，发现了google第一条方法来自于 easyengine1234## You can kill it usingsudo fuser -k 80/tcp## And then try restarting nginx againservice nginx start 然后试了试，还是不行。没办法，继续找呗~ 后来吧，找了几十篇就不行，最后找到了一个帖子Drupal 解决方案是编辑nginx的配置文件sudo gedit /etc/nginx/sites-available/default 修改下面这一段listen 80; listen [::]:80 default_server;为listen 80; listen [::]:80 ipv6only=on default_server; 将上面的两个方法相结合之后终于解决了。","categories":[],"tags":[{"name":"nginx 服务器","slug":"nginx-服务器","permalink":"http://blog.xutengfeng.com/tags/nginx-服务器/"}]},{"title":"ios 微信分享成功，回调方法不执行","slug":"ios-微信分享成功，回调方法不执行","date":"2018-12-03T08:01:06.000Z","updated":"2018-12-03T08:01:25.892Z","comments":true,"path":"2018/12/03/ios-微信分享成功，回调方法不执行/","link":"","permalink":"http://blog.xutengfeng.com/2018/12/03/ios-微信分享成功，回调方法不执行/","excerpt":"","text":"关于微信在ios上分享成功却不执行回调的问题 在ios上，公众号微信分享朋友圈成功不执行回调，但是在android可以 在ios上，取消公众号微信分享朋友圈却能执行回调， 在ios上，微信分享发送给朋友、分享朋友圈都能成功执行回调 解决方法将回调方法执行的函数，用setTimeout包裹起来，当然其他一些延迟执行的方法应该也行123setTimeout(() =&gt; &#123; // do sth &#125;, 500); 方法来自于 saimentiekeghost","categories":[],"tags":[]},{"title":"技巧型模式","slug":"技巧型模式","date":"2018-07-29T11:31:22.000Z","updated":"2018-07-29T11:34:10.000Z","comments":true,"path":"2018/07/29/技巧型模式/","link":"","permalink":"http://blog.xutengfeng.com/2018/07/29/技巧型模式/","excerpt":"","text":"技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题 链模式（Operate of Responsibility Pattern） 委托模式（Command Pattern） 数据访问对象模式（Interpreter Pattern） 节流模式模式（Iterator Pattern） 简单模板模式（Mediator Pattern） 惰性模式（Memento Pattern） 参与者模式（Observer Pattern） 等待者模式（State Pattern） 链模式（Operate of Responsibility）","categories":[],"tags":[]},{"title":"行为型模式","slug":"行为型模式","date":"2018-07-25T15:04:56.000Z","updated":"2018-07-29T10:08:55.000Z","comments":true,"path":"2018/07/25/行为型模式/","link":"","permalink":"http://blog.xutengfeng.com/2018/07/25/行为型模式/","excerpt":"","text":"结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） 模板方法模式（Template Method）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209/** * 模板方法模式（Template Method）：父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中， * 使得子类可以不改变父类的算法结构的同时可重新定义算法中的某些实现步骤 */// 提示框归一化// 创建基本提示框// 模板类 基础提示框 data渲染数据class Alert &#123; constructor(data) &#123; // 没有数据则返回，防止后面程序执行 if (!data) &#123; return; &#125; // 设置内容 this.content = data.content; // 创建提示框面板 this.panel = document.createElement('div'); // 创建提示内容组件 this.contentNode = document.createElement('p'); // 创建确定按钮组件 this.confirmBtn = document.createElement('span'); // 创建关闭按钮组件 this.closeBtn = document.createElement('span'); // 为提示框面板添加类 this.panel.className = 'alert'; // 为关闭按钮添加类 this.closeBtn.className = 'a-close'; // 为确定按钮添加类 this.confirmBtn.className = 'a-confirm'; // 为确定按钮添加文案 this.confirmBtn.innerHTML = data.confirm || '确认'; // 为提示内容添加文本 this.contentNode.innerHTML = this.content; // 点击确定按钮执行方法 如果data中有success方法则为success方法，否则为空函数 this.succes = data.success || function() &#123;&#125;; // 点击关闭按钮执行方法 this.fail = data.fail || function() &#123;&#125;; &#125; // 创建方法 init() &#123; // 生成提示框 this.panel.appendChild(this.closeBtn); this.panel.appendChild(this.contentNode); this.panel.appendChild(this.confirmBtn); // 插入到页面中 document.body.appendChild(this.panel); // 绑定事件 this.bindEvent(); // 显示提示框 this.show(); &#125; bindEvent() &#123; // 关闭按钮点击事件 this.closeBtn.onclick = () =&gt; &#123; // 执行关闭取消方法 this.fail(); // 隐藏弹层 this.hide(); &#125;; &#125; // 隐藏弹层方法 hide() &#123; this.panel.style.display = 'none'; &#125; // 显示弹层方法 show() &#123; this.panel.style.display = 'block'; &#125;&#125;// 根据模板创建类class RightAlert extends Alert &#123; constructor(data) &#123; super(data); // 为确认按钮添加right类设置位置居右 this.confirmBtn.className = `$&#123;this.confirmBtn.className&#125; right`; &#125;&#125;// 标题提示框class TitleAlert extends Alert &#123; constructor(data) &#123; super(data); // 设置标题内容 this.title = data.title; // 创建标题组件 this.titleNode = document.createElement('h3'); // 标题组件中写入标题内容 this.titleNode.innerHTML = this.title; &#125; // 最基本提示框创建方法拓展 init() &#123; // 插入标题 this.panel.insertBefore(this.titleNode, this.panel.firstChild); // 继承基本提示框的init方法 super.init(); &#125;&#125;// 继承类也可作为模板类// 带有取消按钮的弹出框class CancelAlert extends TitleAlert &#123; constructor(data) &#123; super(data); // 取消按钮文案 this.cancel = data.cancel; // 创建取消按钮 this.cancelBtn = document.createElement('span'); // 为取消按钮添加类 this.cancelBtn.className = 'cancel'; // 设置取消按钮内容 this.cancelBtn.innerHTML = this.cancel || '取消'; &#125; init() &#123; // 继承标题提示框创建方法 super.init(); // 由于取消按钮要添加在末尾，所以在创建完其他组件后添加 this.panel.appendChild(this.cancelBtn); &#125; bindEvent() &#123; // 标题提示框绑定事件方法继承 super.bindEvent(); // this.bindEvent(); // 取消按钮绑定事件 this.cancelBtn.onclick = () =&gt; &#123; this.fail(); this.hide(); &#125;; &#125;&#125;new CancelAlert(&#123; title: '提示标题', content: '提示内容', success: () =&gt; console.log('ok'), fail: () =&gt; console.log('cancel')&#125;).init();// 创建多类导航/** * 其实模板方法模式不仅仅在我们归一化组件时使用，有时候创建页面时也是很常用的， * 比如创建三类导航，第一类是基础的，第二类是多了消息提醒功能，第三类多了后面 * 显示网址功能 */// 格式化字符串方法const formatString = (str, data) =&gt; str.replace(/\\&#123;#(\\w+)#\\&#125;/g, (match, key) =&gt; typeof data[key] === undefined ? '' : data[key]);// 基础导航const Nav = function(data) &#123; // 基础导航样式模板 this.item = '&lt;a href=\"&#123;#href#&#125;\" title=\"&#123;#title#&#125;\"&gt;&#123;#name#&#125;&lt;/a&gt;'; // 创建字符串 this.html = ''; // 格式化数据 for (let index = 0; index &lt; data.length; index += 1) &#123; this.html += formatString(this.item, data[index]); &#125; return this.html;&#125;;// 带有消息提示信息导航const NumNav = function(data) &#123; // 消息提醒信息组件模板 const tpl = '&lt;b&gt;&#123;#num#&#125;&lt;/b&gt;'; // 装饰数据 for (let i = 0; i &lt; data.length; i += 1) &#123; data[i].name += data[i].name + formatString(tpl, data[i]); &#125; // 继承基础导航类，并返回字符串 return Nav.call(this, data);&#125;;// 带有链接的导航const LinkNav = function(data) &#123; // 链接地址模板 const tpl = '&lt;span&gt;&#123;#link#&lt;/span&gt;'; // 装饰数据 for (let i = 0; i &lt; data.length; i++) &#123; data[i].name += `$&#123;data[i]&#125;$&#123;formatString(tpl, data[i])&#125;`; &#125; // 继承基础导航类，并返回字符串 return Nav.call(this, data);&#125;;// 创建导航更容易// 获取导航容器const nav = document.getElementById('content');// 添加内容nav.innerHTML = NumNav([ &#123; href: 'https://www.baidu.com', title: '百度一下，你就知道', name: '百度', num: '10' &#125;, &#123; href: 'https://www.taobao.com', title: '淘宝商城', name: '淘宝', num: '2' &#125;, &#123; href: 'https://www.qq.com', title: '腾讯首页', name: '腾讯', num: '3' &#125;]); 观察者模式（Observer）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 观察者模式（Observer）：又被称作发布-订阅者模式或消息机制，定义了一种依赖关系， * 决绝了主题对象与观察者之间功能的耦合 */// 将观察者放在闭包中，当页面加载就立即执行const Observer = (function() &#123; // 防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存 const __messages = &#123;&#125;; return &#123; // 注册消息接口 /** * @param &#123;string&#125; type 消息类型 * @param &#123;function&#125; fn 相应的处理动作 */ regist: (type, fn) =&gt; &#123; // 如果此消息不存在则应该创建一个该消息类型 if (typeof __messages[type] === 'undefined') &#123; // 将该动作推入到消息对应的动作执行队列中 __messages[type] = [fn]; // 如果此消息存在 &#125; else &#123; // 将动作方法推入该消息对应的动作执行序列中 __messages[type].push(fn); &#125; &#125;, // 发布消息接口 fire: (type, args = &#123;&#125;) =&gt; &#123; // 如果该消息没有被注册，则返回 if (!__messages[type]) &#123; return; &#125; const events = &#123; type, args &#125;; // 便利消息动作 for (let i = 0; i &lt; __messages[type].length; i += 1) &#123; // 依次执行注册的消息对应的动作序列 __messages[type][i].call(this, events); &#125; &#125;, // 移除消息接口 remove: (type, fn) =&gt; &#123; // 如果消息动作队列存在 if (Array.isArray(__messages[type])) &#123; // 从最后一个消息动作便利 let i = __messages[type].length - 1; for (; i &gt;= 0; i -= 1) &#123; // 如果存在该动作则在消息动作系列中移除相应动作 __messages[type][i] === fn &amp;&amp; __messages[type].splice(i, 1); &#125; &#125; &#125; &#125;;&#125;)();Observer.regist('test', (e) =&gt; console.log(e.type, e.args.msg));Observer.fire('test', &#123; msg: '传递参数' &#125;);const Student = function(result) &#123; // 学生回答结果 this.result = result; // 学生回答问题动作 this.say = () =&gt; console.log(this.result);&#125;;Student.prototype.answer = function(question) &#123; // 注册参数问题 Observer.regist(question, this.say);&#125;;// 学生呼呼睡觉，此时不能回答问题Student.prototype.sleep = function(question) &#123; console.log(`$&#123;this.result&#125; $&#123;question&#125; 已被注销`); // 取消对老师问题的监听 Observer.remove(question, this.say);&#125;;const Teacher = function() &#123;&#125;;// 教师提问题的方法Teacher.prototype.ask = function(question) &#123; console.log(`问题是：$&#123;question&#125;`); // 发布提问消息 Observer.fire(question);&#125;;const student1 = new Student('学生1回答问题');const student2 = new Student('学生2回答问题');const student3 = new Student('学生3回答问题');student1.answer('什么是设计模式');student1.answer('简述观察者模式');student2.answer('什么是设计模式');student3.answer('什么是设计模式');student3.answer('简述观察者模式');student3.sleep('简述观察者模式');const teacher = new Teacher();teacher.ask('什么是设计模式');teacher.ask('简述观察者模式'); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 状态模式（State）当一个对象的内部状态发生改变时，会导致行为的改变， * 这看起来像是改变了对象 */// 当需要判断的分支有点多时// function showResult(result) &#123;// if (result === 0) &#123;// //// &#125; else if (result === 1) &#123;// //// &#125; else if (result === 2) &#123;// //// &#125; else if (result === 3) &#123;// //// &#125;// &#125;// 状态对象的实现// 可以将不同的判断结果疯转在状态对象内，然后该状态对象返回一个可被调用的接口方法，用于调用状态对象内部的某种方法const ResultState = function() &#123; // 判断结果保存在内部状态中 const States = &#123; // 每种状态作为一种独立方法保存 state0: function() &#123; // 处理结果0 console.log('这是第一种情况'); &#125;, state1: function() &#123; // 处理结果1 console.log('这是第二种情况'); &#125;, state2: function() &#123; // 处理结果2 console.log('这是第三种情况'); &#125;, state3: function() &#123; // 处理结果3 console.log('这是第四种情况'); &#125;, &#125;; function show(result) &#123; States[`state$&#123;result&#125;`] &amp;&amp; States[`state$&#123;result&#125;`](); &#125; return &#123; // 返回调用状态方法接口 show &#125;;&#125;();// 展示结果ResultState.show(3);// 创建超级玛丽状态类const MarryState = function() &#123; // 内部状态私有变量 let _currentState = &#123;&#125;; const states = &#123; jump: () =&gt; console.log('jump'), move: () =&gt; console.log('move'), shoot: () =&gt; console.log('shoot'), squat: () =&gt; console.log('squat'), &#125;; // 动作控制类 const Action = &#123; // 改变状态方法 changeState: function(...rest) &#123; // 组合动作通过传递多个参数实现 const arg = rest; // 重置内部状态 _currentState = &#123;&#125;; if (arg.length) &#123; // 遍历动作 for (let i = 0; i &lt; arg.length; i += 1) &#123; // 向内部状态添加动作 _currentState[arg[i]] = true; &#125; &#125; return this; &#125;, // 执行动作 goes: function() &#123; console.log('触发一次动作'); // 遍历内部状态保存的动作 for (let key in _currentState) &#123; if (_currentState.hasOwnProperty(key)) &#123; // 如果该动作存在则执行 states[key] &amp;&amp; states[key](); &#125; &#125; return this; &#125;, &#125;; // 返回接口方法 change、goes return &#123; change: Action.changeState, goes: Action.goes &#125;;&#125;;const marry = new MarryState();marry.change('jump', 'shoot') .goes() .goes() .change('shoot') .goes(); 策略模式（strategy）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 策略模式（strategy）：将定义的一组算法封装起来，使其相互之间可以替换。 * 封装的算法具有一定独立性，不会随客户端变化而变化。 */// 策略对象// 价格策略对象const PriceStrategy = function() &#123; // 内部算法对象 const strategy = &#123; // 100返30 return30: (price) =&gt; &#123; // parseInt 可通过~~|等运算符替换，要注意此时price要在[-2147483648, 2147483647]之间 // +price转化为数字类型 return +price + parseInt(price / 100, 10) * 30; &#125;, // 100返50 return50: (price) =&gt; +price + parseInt(price / 100, 10) * 50, // 9折 percent90: (price) =&gt; &#123; // Javascript在处理小数乘除法有bug，故运算前转化为证书 return price * 100 * 90 / 10000; &#125;, // 8折 percent80: (price) =&gt; price * 100 * 80 / 10000, // 5折 percent50: (price) =&gt; price * 100 * 50 / 10000, &#125;; // 策略算法调用接口 return function(algorithm, price) &#123; // 如果算法存在，则调用算法，否则返回false return strategy[algorithm] &amp;&amp; strategy[algorithm](price); &#125;;&#125;;const price = PriceStrategy('return50', '314.67');console.log(price);// 表单验证// 表单正则验证策略对象const InputStrategy = function() &#123; const strategy = &#123; // 是否为空 notNull: (value) =&gt; /^\\s+$/.test(value) ? '请输入内容' : '', // 是否是一个数字 number: (value) =&gt; /^\\d+(\\.\\d+)?$/.test(value) ? '' : '请输入数字', // 是否是本地电话 phone: (value) =&gt; /$\\d&#123;3&#125;\\-\\d&#123;8&#125;$|^\\d&#123;4&#125;\\-\\d&#123;7&#125;$/.test(value) ? '' : '请输入正确的电话号码格式，如：010-12345678或0418-1234567' &#125;; return &#123; /** * 验证接口 * @param &#123;String&#125; type 算法 * @param &#123;String&#125; value 表单值 */ check: function(type, value) &#123; // 去除收尾空白符 value = value.replace(/^\\s+|\\s+$/g, ''); return strategy[type] ? strategy[type](value) : '没有该类型的检查方法'; &#125;, // 添加策略 addStrategy: (type, fn) =&gt; strategy[type] = fn &#125;;&#125;(); 职责链模式（chain of Responsibility）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 职责链模式（chain of Responsibility）：解决请求的发送者于请求的接受者之间的耦合， * 通过职责链的多个对象对分解请求流程，实现庆祝在多个对象之间传递，直到最后一个对象完成 * 请求的处理 */// 分解需求// 既然完成一个需求要做这么多的事情，那就把每间事情独立出换一个模块对象去处理，这样完整的需求就被分解成一部分// 一部分相互独立的模块需求，通过这些对象的分工协作，每个对象只做与自己分内的事，无关的事情传到下一个对象中去做，// 直到需求完整// 第一站--请求模块// 县创建一个异步请求模块对象，它应该只做向服务器端发送请求的事情/** * 异步请求对象（简化版本） * @param &#123;Object&#125; data 请求数据 * @param &#123;String&#125; dealType 响应数据处理对象 * @param &#123;Object&#125; dom 事件源 */const sendData = function(data, dealType, dom) &#123; // XHR对象 简化版本 IE另行处理 const xhr = new XMLHttpRequest(); let url = 'getData.php?mode=userInfo'; // 请求返回时间 xhr.onload = function() &#123; // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; dealData(xhr.responseText, dealType, dom); &#125; else &#123; // 请求失败 &#125; &#125;; // 拼接请求字符串 for (let i in data) &#123; if (data.hasOwnProperty(i)) &#123; url += `&amp;$&#123;i&#125;=$&#123;data[i]&#125;`; &#125; &#125; // 发送异步请求 xhr.open('get', url, true); xhr.send(null);&#125;;// 下一站--响应数据适配模块// 在这个模块对象中没有对返回的结果做任何逻辑处理，直接将得到的结果传入响应数据// 适配模块对象方法中，所以对于响应数据适配模块页应该处理一件事--适配相应数据// （Ajax请求返回的数据）/** * 处理响应数据 * @param &#123;Object&#125; data 请求数据 * @param &#123;String&#125; dealType 响应数据处理对象 * @param &#123;Object&#125; dom 事件源 */const dealData = function(data, dealType, dom) &#123; // 对象toString方法简化引用 const dataType = Object.prototype.toString.call(data); // 判断相应数据处理对象 switch (dealType) &#123; case 'sug': // 如果数据为数组 if (dataType === '[object Array]') &#123; // 创建提示框组件 return createSug(data, dom); &#125; // 将相应的对象数据转化为数组 if (dataType === '[object object') &#123; const newData = []; for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; newData.push(data[key]); &#125; &#125; // 创建提示框组件 return createSug([data], dom); &#125; return createSug([data, dom]); case 'validate': // 创建校验组件 return createValidateResult(data, dom); default: break; &#125;&#125;;// 重点站--创建组件模块// 在响应数据适配模块中，适配了响应的数据，并将适配后的数据传入下一级创建组件模块中。// 所以创建组件模块应该做的一件事是--根据相应数据创建组件/** * 创建提示框组件 * @param &#123;Array&#125; data 响应适配数据 * @param &#123;Object&#125; dom 事件源 */const createSug = function(data, dom) &#123; let i = 0; const len = data.length; let html = ''; // 拼接每一条提示语句 for (;i &lt; len; i += 1) &#123; html += `&lt;li&gt;&lt;$&#123;data[i]&#125;/li&gt;`; &#125; // 显示提示框 dom.parentNode.getElementsByTagName('ul')[0].innerHTML = html;&#125;;/** * 创建校验组件 * @param &#123;Array&#125; data 响应适配数据 * @param &#123;Object&#125; dom 事件源 */const createValidateResult = function(data, dom) &#123; // 显示校验结果 dom.parentNode.getElementsByTagName('span')[0].innerHTML = data;&#125;; 命令模式（Command）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 命令模式（Command）：将请求与实现解耦并风封装成独立对象， * 从而使不同的请求对客户端实现参数化 */// 需求分析// 做个活动页面，平铺式的结构，不过页面的每个模块都有些类似的地方// 比如每个预览产品图片区域，都有一行标题，然后标题的下面是产品图片// 只是图片的数量与排列不同// 命令模式就是将请求模块与实现模块解耦。命令模式是将创建模块的逻辑封装在一个// 对象里，这个对象提供一个参数化的请求接口，通过调用这个接口并传递一些参数实现// 调用命令对象内部的一些方法// 请求部分很简单，只需要按照给定的参数格式书写指令即可，所以实现部分的封装才是// 重点，因为它要为请求部分提供所需方法// 命令对象// 既然动态展示不同模块，所以创建元素这一需求就是变化的，因此创建元素方法、// 展示方法应该被命令化// 模块实现模块const viewCommand = (function() &#123; const tpl = &#123; // 展示图片结构模板 product: `&lt;div&gt; &lt;img src=\"&#123;#src&#125;\" /&gt; &lt;p&gt;&#123;#text&#125;&lt;/p&gt; &lt;/div&gt;`, // 展示标题结构模板 title: ` &lt;div class=\"title\"&gt; &lt;div class=\"main\"&gt; &lt;h2&gt;&#123;#title&#125;&lt;/h2&gt; &lt;p&gt;&#123;#tips&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; `, &#125;; let html = ''; const formatString = (str, data) =&gt; str.replace(/\\&#123;#(\\w+)#\\&#125;/g, (match, key) =&gt; typeof data[key] === undefined ? '' : data[key]); // 方法集合 const Action = &#123; // 创建方法 create: (data, view) =&gt; &#123; // 解析数据 如果数据是一个数组 if (Array.isArray(data)) &#123; // 遍历数组 for (let i = 0, len = data.length; i &lt; len; i += 1) &#123; // 将格式化之后的字符串缓存到html中 html += formatString(tpl[view], data[i]); &#125; &#125; else &#123; // 直接格式化字符串缓存到html中 html += formatString(tpl[view], data); &#125; &#125;, // 展示方法 display: function(container, data, view) &#123; // 如果传入数据 if (data) &#123; // 根据给定数据创建视图 this.create(data, view); &#125; // 展示模块 document.getElementById(container).innerHTML = html; // 展示后清空缓存的字符串 html = ''; &#125; &#125;; // 命令接口 return function excute(msg) &#123; // 解析命令，如果msg.param不是数组则将其转化为数组（apply方法要求第二个参数为数组） msg.param = Array.isArray(msg.param) ? msg.param : [msg.param]; // Action内部调用的方法引用this，所以此处为保证作用域this执行传入Action Action[msg.command](...msg.param); &#125;;&#125;)();// 使用// 产品展示数据const productData = [ &#123; src: 'command/02.jpg', text: '绽放的桃花' &#125;, &#123; src: 'command/02.jpg', text: '绽放的桃花' &#125;, &#123; src: 'command/02.jpg', text: '绽放的桃花' &#125;,];// 模块标题数据const titleData = &#123; title: '夏日里的一片温馨', tips: '暖暖的温情带给人们家的感受'&#125;;viewCommand(&#123; // 参数说明 方法 display command: 'display', // 参数说明 param1元素容器 param2标题数据 param3元素模板 param: ['title', titleData, 'title']&#125;); 访问者模式（visitor）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 访问者模式（visitor）：针对于对象结构中的元素，定义在不改变该对象的前提下 * 访问结构中元素的新方法 */// 设置样式在用DOM2级时间为页面中的元素绑定事件的时候，为该元素设置一些css样式，// 在标准浏览器下可以成功，在低版本IE下面不成功const bindEvent = function(dom, type, fn) &#123; if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false); &#125; else if (dom.attachEvent) &#123; dom.attachEvent(`on$&#123;type&#125;`, fn); &#125; else &#123; dom[`on$&#123;type&#125;`] = fn; &#125;&#125;;// const demo = document.getElementById('demo');// bindEvent(demo, 'click', function() &#123;// this.style.background = 'red';// &#125;);// 低版本IE会报错，提示说'this.style为空或不为对象'// 访问操作元素function bindIEEvent(dom, type, fn, data = &#123;&#125;) &#123; dom.attachEvent(`on$&#123;type&#125;`, (e) =&gt; &#123; fn.call(dom, e, data); &#125;);&#125;// 其实实现的核心就是调用了一次call方法。call和apply的作用就是更改函数执行时的作用域// 这正是访问者模式的精髓，通过这两种方法就可以让某个对象在其他作用域中运行// 对象访问器const Visitor = (function() &#123; return &#123; // 截取方法 splice: (...rest) =&gt; &#123; // splice 方法参数，从元参数的第二个参数开始算起 const args = Array.prototype.splice.call(rest, 1); // 对第一个参数对象执行splice方法 return Array.prototype.splice.apply(rest[0], args); &#125;, // 追加数据方法 push: function(...rest) &#123; // 强化类数组对象，使他拥有length属性 const len = rest[0].length || 0; // 添加的数据从元参数的第二个参数玄奇 const args = this.splice(rest, 1); console.log(&#123; args &#125;); // 矫正length属性 rest[0].length = len + rest.length - 1; // 对第一个参数对象执行push方法 return Array.prototype.push.apply(rest[0], args); &#125;, // 弹出最后一次添加的元素 pop: (...rest) =&gt; Array.prototype.pop.apply(rest[0]) &#125;;&#125;)();const a = new Object();console.log(a.length);Visitor.push(a, 1, 2, 3, 4);console.log(a.length);Visitor.push(a, 4, 5, 6);console.log(a);console.log(a.length);Visitor.pop(a);console.log(a.length);Visitor.splice(a, 2);console.log(a); 中介者模式（Mediator）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/** * 中介者模式（Mediator）：通过中介对象封装一系列对象之间的交互，使对象之间不再 * 相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。 */// 中介者对象const Mediator = function() &#123; // 消息对象 const _msg = &#123;&#125;; return &#123; /** * 订阅消息方法 * @param type 消息名称 * @param action 消息回调函数 */ register: (type, action) =&gt; &#123; // 如果该消息存在 if (_msg[type]) &#123; // 存入毁掉函数 _msg[type].push(action); &#125; else &#123; // 不存在则建立该消息容器 _msg[type] = []; _msg[type].push(action); &#125; &#125;, /** * 发布消息方法 * @param type 消息名称 */ send: (type) =&gt; &#123; // 如果该消息已经被订阅 if (_msg[type]) &#123; // 便利已存储的消息毁掉函数 for (const action of _msg[type]) &#123; // 执行该毁掉函数 action &amp;&amp; action(); &#125; &#125; &#125; &#125;;&#125;();// 单元测试// 订阅demo下拍戏 执行毁掉函数00输出 firstMediator.register('demo', () =&gt; console.log('first'));// 订阅demo消息 执行毁掉函数--输出secondMediator.register('demo', () =&gt; console.log('second'));// 发布demo消息Mediator.send('demo');// 订阅消息/** * 显影导航小组件 * @param &#123;String&#125; mod 模块 * @param &#123;String&#125; tag 处理的标签（消息提醒b，网址span） * @param &#123;Boolean|String&#125; showOrHide 显示还是隐藏 */const showHideNavWidget = function(mod, tag, showOrHide) &#123; // 获取导航模块 const modE = document.getElementById(mod); // 获取下面的标签名为tag的元素 const tagE = mod.getElementsByTagName(tag); // 如果设置为false或者为hide则值为hidden，否则为visible const isShow = (!showOrHide || showOrHide === 'hide') ? 'hidden' : 'visible'; // 占位隐藏这些标签 for (let i = tag.length; i &gt; 0; i -= 1) &#123; tag.style.visibility = showOrHide; &#125;&#125;;// 用户收藏导航模块(function() &#123; // ...其他交互逻辑 // 订阅隐藏用户收藏导航消息提醒消息 Mediator.register('hideAllNavNum', () =&gt; &#123; showHideNavWidget('collection_nav', 'b', false); &#125;); // 订阅显示用户收藏导航消息提醒消息 Mediator.register('showAllNavNum', () =&gt; &#123; showHideNavWidget('collection_nav', 'b', true); &#125;); // 订阅隐藏用户收藏导航网址消息 Mediator.register('hideAllNavUrl', () =&gt; &#123; showHideNavWidget('collection_nav', 'span', false); &#125;); // 订阅显示用户收藏导航网址消息 Mediator.register('showAllNavUrl', () =&gt; &#123; showHideNavWidget('collection_nav', 'span', true); &#125;);&#125;)();// 用户推荐导航(function() &#123; // ...其他交互逻辑 // 订阅隐藏推荐用户导航消息提醒消息 Mediator.register('hideAllNavNum', () =&gt; &#123; showHideNavWidget('recommend_nav', 'b', false); &#125;); // 订阅显示推荐用户导航消息提醒消息 Mediator.register('showAllNavNum', () =&gt; &#123; showHideNavWidget('recommend_nav', 'b', true); &#125;);&#125;);// 最近常用导航(function() &#123; // ...其他交互逻辑 // 订阅隐藏最近常用导航网址消息 Mediator.register('hideAllNavNum', () =&gt; &#123; showHideNavWidget('recently_nav', 'span', false); &#125;); // 订阅显示最近常用导航网址消息 Mediator.register('showAllNavNum', () =&gt; &#123; showHideNavWidget('recently_nav', 'span', true); &#125;);&#125;);// 发布消息// 设置层模块(function() &#123; // 消息提醒选框 const hideNum = document.getElementById('hide_num'); // 网址选框 const hideUrl = document.getElementById('hide_url'); // 消息提醒选框事件 hideNum.onchange = function() &#123; // 如果勾选 if (hideNum.checked) &#123; // 中介者发布隐藏消息提醒功能消息 Mediator.send('hideAllNavNum'); &#125; else &#123; // 中介者发布显示消息提醒功能消息 Mediator.send('showAllNavNum'); &#125; &#125;; // 网址选框事件 hideUrl.onchange = function() &#123; // 如果勾选 if (hideUrl.checked) &#123; // 中介者发布隐藏所有网址功能消息 Mediator.send('hideAllNavUrl'); &#125; else &#123; // 中介者发布显示所有网址功能消息 Mediator.send('showAllNavUrl'); &#125; &#125;;&#125;)(); 备忘录模式（Memento）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 备忘录模式（Memento）：在不破坏对象的封装性的前提下， * 在对象之外捕获并保存该对象内部的状态以便日后对象使用 * 或者对象恢复到以前的某个状态 */function showPage(page, data) &#123;&#125;// 新闻缓存器// Page备忘录类const Page = function() &#123; // 信息缓存对象 const cache = &#123;&#125;; /** * 主函数 * @param &#123;Number&#125; page 页码 * @param &#123;Function&#125; fn 成功回调函数 */ return function(page, fn) &#123; // 判断该页数据是否存在缓存中 if (cache[page]) &#123; // 恢复到该页状态，显示该页内容 showPage(page, cache[page]); // 执行成功回调函数 fn &amp;&amp; fn(); &#125; else &#123; // 若缓存Cache中无该页数据 $.post('./data/getNewsData.php', &#123; // 请求携带数据page页码 page &#125;, (res) =&gt; &#123; // 成功返回 if (res.errNo === 0) &#123; // 显示该页数据 showPage(page, res.data); cache[page] = res.data; fn &amp;&amp; fn(); &#125; else &#123; // 处理异常 &#125; &#125;); &#125; &#125;;&#125;; 迭代器模式（Iterator）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354/** * 迭代器模式（Iterator）：在不暴露对象内部结构的同事，可以顺序地访问聚合对象内部的元素 */// 迭代器const Iterator = function(items, container) &#123; // 获取父容器，若container参数存在，并且可以获取该元素则获取，否则获取document const parent = container &amp;&amp; document.getElementById(container) || document; // 获取元素 const childs = parent.getElementsByTagName(items); // 获取元素长度 const length = items.length; // 当前索引值，默认：0 let index = 0; // 缓存源生数组的splice方法 const splice = [].splice; return &#123; // 获取第一个元素 first: () =&gt; &#123; index = 0; // 矫正当前索引 return items[index]; &#125;, // 获取最后一个元素 second: () =&gt; &#123; index = length - 1; // 矫正当前索引 return items[index]; &#125;, // 获取前一个元素 pre: () =&gt; &#123; if (--index &gt; 0) &#123; // 如果索引值大鱼0 return items[index]; // 获取索引值对应的元素 &#125; index = 0; // 索引值为0 return null; // 返回空 &#125;, // 获取后一个元素 next: () =&gt; &#123; if (++index &lt; length) &#123; // 如果索引值小鱼长度 return items[index]; // 获取索引值对应的元素 &#125; index = length - 1; // 索引值为0 return null; // 返回空 &#125;, // 获取某一个元素 get: (num) =&gt; &#123; // 如果num大于等于0再正向获取，否则逆向获取 index = num &gt;= 0 ? num % length : num % length + length; // 返回对应元素 return items[index]; &#125;, // 对每一个元素执行某一个方法 dealEcah: (fn) =&gt; &#123; // 第二个参数开始为回调函数中参数 const args = splice.call(arguments, 1); // 遍历元素 for (const item of items) &#123; fn.apply(item, args); &#125; &#125;, // 对某一个元素执行某一个方法 dealItem: (num, fn) =&gt; &#123; // 对元素执行回调函数，注：1 第三个参数开始为毁掉函数中参数 2 通过this.get 方法设置index索引值 fn.apply(this.get(num), splice.call(arguments, 2)); &#125;, // 排他方法处理某一个元素 exclusive: (num, allFn, numFn) =&gt; &#123; // 对所有元素执行回调函数 this.dealEcah(allFn); // 如果num类型为数组 if (Array.isArray(num)) &#123; // 遍历num数组 for (const n of num) &#123; // 分别处理数组中每一个元素 this.dealItem(n, numFn); &#125; &#125; else &#123; this.dealItem(num, numFn); &#125; &#125;, &#125;;&#125;;// const demo = new Iterator('li', 'container');// console.log(demo.fisrt()); // &lt;li&gt;1&lt;/li&gt;// console.log(demo.pre()); // null// console.log(demo.next()); // &lt;li&gt;2&lt;/li&gt;// console.log(demo.get(2000)); // &lt;li&gt;1&lt;/li&gt;// // 处理所有元素// demo.dealEcah(function(text, color) &#123;// this.innerHTML = text;// this.style.backgroundColor = color;// &#125;, 'test', 'pink');// // 排他思想处理第3个和第4个元素// demo.exclusive([2, 3], function() &#123;// this.innerHTML = '被排除的';// this.style.backgroundColor = 'green';// &#125;, function() &#123;// this.innerHTML = '选中的';// this.style.backgroundColor = 'red';// &#125;);/** * 数组迭代器 * 依次对数组中每一个元素遍历，并将钙元素的索引于索引值传入回调函数中 */const eachArray = (arr, fn) =&gt; &#123; let i = 0; const len = arr.length; // 遍历数组 for (;i &lt; len; i += 1) &#123; // 依次执行回调函数，注意回调函数中传入的参数第一个为索引，第二个为该索引对应的值 if (fn.call(arr[i], i, arr[i]) === false) &#123; break; &#125; &#125;&#125;;/** * 对象迭代器 * 对象迭代器于与数组迭代器比较类似，但传入回调函数中的为对象的属性与对象的属性值 */const eachObject = (obj, fn) =&gt; &#123; // 遍历对象中的每一个属性值 for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 依次执行回调函数，注意回调函数中传入的参数第一个为属性，第二个为该属性对应的值 if (fn.call(obj[key], key, obj[key]) === false) &#123; break; &#125; &#125; &#125;&#125;;// 创建一个数组const arr = new Array(5).fill(0).map((item, i) =&gt; i + 1);eachArray(arr, (i, data) =&gt; console.log(i, data));const obj = &#123; a: 23, b: 56, c: 67 &#125;;eachObject(obj, (i, data) =&gt; console.log(i, data));// 同步变量const A = &#123; // 所有用户共有 common: &#123;&#125;, // 客户端数据 client: &#123; user: &#123; username: '桂仁沛', uid: 123 &#125; &#125;, server: &#123;&#125;&#125;;// 想要获取客户端（client）的用户名（username）数据可以通过一个同步变量迭代取值器来实现// 同步变量迭代取值器const AGetter = (key) =&gt; &#123; // 如果不存在A则返回未定义 if (!A) &#123; return undefined; &#125; let result = A; // 获取同步变量A对象 const keyI = key.split('.'); // 解析属性层次序列 // 迭代同步变量A对象属性 for (let i = 0, len = keyI.length; i &lt; len; i += 1) &#123; // 如果第i层属性存在对应的值则迭代该属性值 if (result[keyI[i]] !== undefined) &#123; result = result[keyI[i]]; &#125; else &#123; return undefined; &#125; &#125; return result;&#125;;// 获取用户名数据console.log(AGetter('client.user.username'));// 获取本地语言数据console.log(AGetter('client.lang.local'));// 有时在交互中会修改或者增加一些同步变量属性数据，比如我们缓存用户在主页中添加体育新闻// 模块这一动作数据，我们可以通过同步变量迭代赋值器来实现// 同步变量迭代赋值器const ASetter = (key, val) =&gt; &#123; // 如果不存在A则返回未定义 if (!A) &#123; return false; &#125; let result = A; // 获取同步变量A对象 const keyI = key.split('.'); // 解析属性层次序列 // 迭代同步变量A对象属性 let i = 0; for (let len = keyI.length; i &lt; len - 1; i += 1) &#123; // 如果第i层属性对应的值不存在，则定义为对象 if (result[keyI[i]] === undefined) &#123; result[keyI[i]] = &#123;&#125;; &#125; // 如果第i层属性对应的值不是对象（Object）的一个实例，则抛出错误 if (!(result[keyI[i]] instanceof Object)) &#123; throw new Error(`A.$&#123;keyI.splice(0, i + 1).join('.')&#125; is not Object`); &#125; // 迭代盖层属性值 result = result[keyI[i]]; &#125; return result[keyI[i]] = val;&#125;;console.log(ASetter('client.module.news.sports', 'on'));// console.log(ASetter('client.user.username.sports', 'on'));/** * 对于绘制特效图片方法dealImage在处理图片数据时需要两个步骤，第一步是迭代每一个图片像素数据 * 第二部是根据给定特效类型选择不同算法处理像素数据 *//** * 绘制特效图片 * @param t 特效类型 * @param x x坐标 * @param y y坐标 * @param w 宽度 * @param h 高度 * @param a 透明度 */// function drawImage(t, x, y, w, h, a) &#123;// // 获取画布图片数据// let ctx = &#123;&#125;;// const canvasData = ctx.getImageData(x, y, w, h);// // 获取像素数据// const data = canvasData.data;// // 遍历没注意像素数据（4个数据表示一个像素点数据，分别代表红色、绿色、蓝色、透明度）// for (let i = 0, len = data.length; i &lt; len; i += 4) &#123;// switch (t) &#123;// // 红色滤镜，将绿色与蓝色取值为0// case 'red':// data[i + 1] = 0;// data[i + 2] = 0;// data[i + 3] = a;// break;// // 绿色滤镜，将红色与蓝色取值为0// case 'green':// data[i] = 0;// data[i + 2] = 0;// data[i + 3] = a;// break;// // 蓝色滤镜，将绿色与红色取值为0// case 'blue':// data[i] = 0;// data[i + 1] = 0;// data[i + 3] = a;// break;// // 平均值灰色滤镜，去三色平均值// case 'gray': &#123;// const num = parseInt((data[i] + data[i + 1] + data[i + 2]) / 3, 10);// data[i] = num;// data[i + 1] = num;// data[i + 2] = num;// data[i + 3] = a;// break;// &#125;// default:// break;// &#125;// &#125;// // ctx.putImageData(canvasData, width + x, y);// &#125;/** * 然而这种处理逻辑并不是最优的，因为每一次遍历都需要进行一次分支判断， * 有太多的无用分支判断 * 可以将循环遍历抽象出来作为一个迭代器存在，每次循环都执行传入迭代器中的某一固定算法，而对于特效算法我们可以上设置在策略对象 * 中实现，通过策略模式与迭代器模式的综合运用即可解决上述分支判断问题 *//** * 绘制特效图片 * @param t 特效类型 * @param x x坐标 * @param y y坐标 * @param w 宽度 * @param h 高度 * @param a 透明度 */function drawImage(t, x, y, w, h, a) &#123; let ctx = &#123;&#125;; const canvasData = ctx.getImageData(x, y, w, h); const data = canvasData.data; // 状态模式封装算法 const Deal = (() =&gt; &#123; const method = &#123; // 默认类型--平均灰度特效 default: (i) =&gt; method['gray'](i), // data[i + 1] = 0; // data[i + 2] = 0; // data[i + 3] = a; // break; // // 绿色滤镜，将红色与蓝色取值为0 // case 'green': // data[i] = 0; // data[i + 2] = 0; // data[i + 3] = a; // break; // // 蓝色滤镜，将绿色与红色取值为0 // case 'blue': // data[i] = 0; // data[i + 1] = 0; // data[i + 3] = a; // break; // // 平均值灰色滤镜，去三色平均值 // case 'gray': &#123; // const num = parseInt((data[i] + data[i + 1] + data[i + 2]) / 3, 10); // data[i] = num; // data[i + 1] = num; // data[i + 2] = num; // data[i + 3] = a; // break; // 红色特效 red: (i) =&gt; &#123; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = a; &#125;, // 平均灰度特效 gray: (i) =&gt; &#123; data[i] = data[i + 1] = parseInt(data[i + 2] = data[i] + data[i + 1] + data[i + 2] / 3, 10); data[i + 3] = a; &#125; // 蓝色特效 // 绿色特效 &#125;; return (type) =&gt; method[type] || method['default']; &#125;)(); // 迭代器处理数据 function eachData(fn) &#123; for (let i = 0, len = data.length; i &lt; len; i += 4) &#123; // 处理一组像素数据 fn(i); &#125; &#125; // 处理数据 eachData(Deal(t)); // ctx.putImageData(canvasData, width + x, y);&#125; 解释器模式（Interpreter）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 解释器模式（Interpreter）：对于一种语言，给出其文法表示形式，并定义一种解释，器 * 通过使用这种解释器来解释语言中定义的句子 */// 统计元素路径Xpath 例如：DIV&gt;DIV2&gt;SPAN// XPath解释器const Interpreter = (function() &#123; // 获取兄弟元素名称 function getSublingName(node) &#123; // 如果存在兄弟元素 if (node.previousSibling) &#123; let name = ''; // 返回兄弟元素名称字符串 let count = 1; // 紧邻兄弟元素中相同名称元素个数 let nodeName = node.nodeName; // 原始节点名称 let sibling = node.previousSibling; // 前一个兄弟元素 // 如果存在前一个兄弟元素 while (sibling) &#123; // 如果节点为元素 并且节点类型与前一个兄弟元素类型相同，并且前一个兄弟元素名称存在 if (sibling.nodeType === 1 &amp;&amp; sibling.nodeType === node.nodeType &amp;&amp; sibling.nodeName) &#123; // 如果节点名称和前一个兄弟元素名称相同 if (nodeName === sibling.nodeName) &#123; // 如果节点名称和前一个兄弟元素名称相同 if (nodeName === sibling.nodeName) &#123; // 节点名称后面添加计数 name += ++count; &#125; else &#123; // 重置相同紧邻节点名称节点个数 count = 1; // 追加新的节点名称 name += `|$&#123;sibling.nodeName.toUpperCase()&#125;`; &#125; &#125; &#125; // 向前获取前一个兄弟元素 sibling = sibling.previousSibling; &#125; return name; &#125; // 否则不存在兄弟元素返回 return ''; &#125; /** * 获取XPath方法 * @param node 目标节点 * @param wrap 容器节点 // 如果不存在容器节点，默认为document */ return function getPath(node, wrap = document) &#123; // 路径数组 let path = []; // 如果当前（目标节点等于容器节点 if (node === wrap) &#123; // 容器节点为元素 if (wrap.nodeType === 1) &#123; // 路径数组中输入容器节点名称 path.push(wrap.nodeName.toUpperCase()); &#125; return path; &#125; // 如果当前节点的父节点不等于容器节点 if (node.parentNode !== wrap) &#123; // 对当前节点的父节点执行遍历操作 path = getPath(node.parentNode, wrap); &#125; else &#123; // 如果当前节点的父元素与容器节点相等 // 容器节点微元素 if (wrap.nodeType === 1) &#123; // 路径数组中输入容器节点名称 path.push(wrap.nodeName.toUpperCase()); &#125; &#125; // 获取元素的兄弟元素名称统计 const sublingsNames = getSublingName(node); // 如果节点为元素 if (node.nodeType === 1) &#123; // 输入当前节点元素名称及其前面兄弟元素名称统计 path.push(node.nodeName.toUpperCase() + sublingsNames); &#125; return path; &#125;;&#125;)();const path = Interpreter(document.getElementById('span7'));console.log(path.join('&gt;')); 本文所有相关内容均来自于张容铭作者的Javascript设计模式，只供学习所用，切勿转载。如有侵权，请联系我，我会立即删除","categories":[],"tags":[{"name":"javascript design","slug":"javascript-design","permalink":"http://blog.xutengfeng.com/tags/javascript-design/"}]},{"title":"Array.prototype.find() not work in IE","slug":"Array-prototype-find-not-work-in-IE","date":"2018-07-13T08:11:39.000Z","updated":"2018-07-13T08:21:21.000Z","comments":true,"path":"2018/07/13/Array-prototype-find-not-work-in-IE/","link":"","permalink":"http://blog.xutengfeng.com/2018/07/13/Array-prototype-find-not-work-in-IE/","excerpt":"","text":"12在修复一个windows版本的微信客户端打开公众号网页的时候碰到的一个问题。在排查完问题之后，发现这样一幅图","categories":[],"tags":[]},{"title":"结构型模式","slug":"结构型模式","date":"2018-07-10T03:38:23.000Z","updated":"2018-07-25T15:04:22.615Z","comments":true,"path":"2018/07/10/结构型模式/","link":"","permalink":"http://blog.xutengfeng.com/2018/07/10/结构型模式/","excerpt":"","text":"结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计 外观模式（Facade Pattern） 适配器模式（Adapter Pattern） 代理模式（Proxy Pattern） 装饰器模式（Decorator Pattern） 桥接模式（Bridge Pattern） 组合模式（Composite Pattern） 享元模式（Flyweight Pattern） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 外观模式（Facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得 * 对子系统接口的访问更容易。在Javascript中有时也会用于对底层结构兼容性做同意封装来简化 * 用户使用 */ // 外观模式实现function addEvent(dom, type, fn) &#123; // 对于支持DOM2级时间处理程序addEventListener方法的浏览器 if (dom.addEventListener) &#123; dom.addEventListener(type, fn, false); // 对于不支持addEventListener方法但支持attachEvent方法的浏览器 &#125; else if (dom.attachEvent) &#123; dom.attach(`on$&#123;type&#125;`, fn); // 对于不支持addEventListener方法也不支持attachEven，但支持on+事件的浏览器 &#125; else &#123; dom[`on$&#123;type&#125;`] = fn; &#125;&#125;/*** 获取事件对象* @param &#123;Object&#125; event 事件对象*/function getEvent(event) &#123; // 标准浏览器返回event，IE下window.event return event || window.event;&#125;/*** 获取元素* @param &#123;Object&#125; event 事件对象*/function getTarget(e) &#123; const event = getEvent(e); // 标准浏览器下event.target, IE下event.srcElement return event.target || event.srcElement;&#125;/*** 阻止默认行为* @param &#123;Object&#125; e 事件对象*/function preventDefault(e) &#123; const event = getEvent(e); // 标准浏览器 if (event.preventDefault) &#123; event.preventDefault(); // IE浏览器 &#125; else &#123; event.returnValue = false; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** 适配器模式（Adapter）：将一个类（对象）的接口（方法或属性转化成另外一个接口，* 以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决*/// 参数适配器// 如果一个函数的参数很多的话，我们要记住它们的顺序是很难的。所以一般是以一个参数对象方式传入的/*** obj.name: name* obj.title: title* ...*/function doSomeThing(obj) &#123; let _adapter = &#123; name: '雨夜清河', title: '设计模式', age: 24, color: 'pink', size: 100, prize: 50 &#125;; for (let key in _adapter) &#123; if (_adapter.hasOwnProperty(key)) &#123; _adapter[key] = obj[key] || _adapter[key]; &#125; &#125;&#125;// 数据适配const arr = ['Javascript', 'book', '前端编程语言', '8月1日'];// 数组中的每个成员代表的意义不同，所以这种数据结构语义不好，所以通常会将其适配成对象形式，比如下面的// 这种对象数据结构const arrToObjAdapter = (arr) =&gt; (&#123; name: arr[0], type: arr[1], title: arr[2], data: arr[3],&#125;);const adapterData = arrToObjAdapter(arr);console.log(&#123; adapterData &#125;);// 服务器端数据适配/*** 如果后端的数据经常变化，比如在某些网站拉取的新闻数据，后端有时无法控制数据的格式，我们在调用dosomething方法时，最好不要直接调用，* 最好现将传递过来的数据是配成对我们可用的数据再使用，这样更安全*/const ajaxAdapter = (data) =&gt; [data['key1'], data['key2'], data['key3']]; 12345678910111213141516171819202122232425262728/** * 装饰者模式（Decorator）：在不改变原对象的基础上，通过对其包装拓展（添加属性或方法） * 使原有对象可以满足用户的更复杂需求 */// 装饰已有的功能对象// 装饰者const decorator = (dom, fn) =&gt; &#123; // 获取事件源 const input = document.getElementById(dom); // 若事件源已经绑定事件 if (typeof input.onclick === 'function') &#123; // 缓存事件源原有绑定事件 const oldClickFn = input.onclick; // 为事件源定义新的事件 input.onclick = () =&gt; &#123; // 事件源原有回调函数 oldClickFn(); // 执行事件源新增回调函数 fn(); &#125;; &#125; else &#123; // 事件源未绑定事件，直接为事件源添加新增回调函数 input.onclick = fn; &#125; // do something&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/** * 桥接模式（Bridge）：在系统沿着多个维度变化的同事，又不增减其复杂度并已达到解耦。 */// 提取共同点// 抽象function changeColor(dom, color, bg) &#123; // 设置元素的字体颜色 dom.style.color = color; // 设置元素的背景颜色 dom.style.background = bg;&#125;// 事件与业务逻辑之间的桥梁const spans = document.getElementsByTagName('span');spans[0].onmouseover = function() &#123; changeColor(this, 'red', '#ddd');&#125;;// changeColor方法中的dom实质上是事件回调函数中的this，那么想要接触它们之间的耦合，// 我们就需要一个桥接方法--匿名回调函数。通过这个回调函数，我们将获取到的this传递到// changeColor函数中，即可实现需求。// 同样对于用户名模块的鼠标移开事件用同样的方式即可spans[0].onmouseout = function() &#123; changeColor(this, '#333', '#F5F5F5');&#125;;// 多元化对象/** * 桥接模式的强大之处不仅仅在此，甚至对于多为的变化也同样适用。比如我们书写一个canvas跑步游戏 * 的时候，对于游戏中的人、小精灵、小球等一系列的实物都有动作单元，而他们的每个动作实现起来方式 * 又是同意的，比如人和精灵和球的运动其实就是位置x和y的变化，球的颜色与精灵的色彩的绘制方式都类似等 * 这样我们就可已经这些多为变化部分，提取出来作为一个抽象运动单元进行保存，而当我们创建实体时， * 将需要的每个抽象动作单元通过桥接，链接在一起运作。这样它们之间不会相互影响并且该方式降低了 * 它们之间的耦合 */// 多维变量类// 运动单元function Speed(x, y) &#123; this.x = x; this.y = y;&#125;Speed.prototype.run = function() &#123; console.log('运动起来！');&#125;;// 着色单元function Color(cl) &#123; this.color = cl;&#125;Color.prototype.draw = function() &#123; console.log('绘制色彩');&#125;;// 变形单元function Shape(sp) &#123; this.shape = sp;&#125;Shape.prototype.change = function() &#123; console.log('改变形状');&#125;;// 说话单元function Speek(wd) &#123; this.word = wd;&#125;Speek.prototype.say = function() &#123; console.log('书写字体');&#125;;// 于是我们想创建一个球类，并且它可以运动，可以着色function Ball(x, y, c) &#123; // 实现运动单元 this.speed = new Speed(x, y); // 实现着色单元 this.color = new Color(c);&#125;Ball.prototype.init = function() &#123; // 实现运动 this.speed.run(); // 实现着色 this.color.draw();&#125;;// 同样我们想创建一个人物类，他可以运动以及说话function People(x, y, f) &#123; this.speed = new Speed(x, y); this.font = new Speek(f);&#125;People.prototype.init = function() &#123; this.speed.run(); this.font.say();&#125;;// 当然我们也可以创建一个精灵类，让它可以运动可以着色可以改变形状function Spirite(x, y, c, s) &#123; this.speed = new Speed(x, y); this.color = new Color(c); this.shape = new Shape(s);&#125;Spirite.prototype.init = function() &#123; this.speed.run(); this.color.draw(); this.shape.change();&#125;;// 创建一个对象桥接method，实现为对象拓展方法的功能// 一个method方法去定义新方法Function.prototype.method = function(name, func) &#123; this.prototype[name] = func; return this;&#125;;/** * 5.1 伪类 * 当一个函数对象被创建时，Function构造器产生的函数对象会运行 * 类似这样的一些代码 * this.prototype = &#123; constructor: this &#125; * 新函数对象被赋予一个prototype属性，其值时一个包含一个constructor属性 * 且属性值为该型函数对象。该prototype对象是存放继承特征的地方。 * 因为Javascript语言没有提供一种方法去确定哪个函数是打算用来作构造器的， * 所以每个函数都会得到一个prototype对象。constructor属性没什么用，重要的是prototype对象 * 但伪类有这么几个缺点 * 1.没有私有环境，所有属性都是公开的 * 2.无法访问super(父类)的方法 * 3.如果你在调用构造器时忘记使用new了，危害相当大！所以建议构造器用大写字母开头 */// 当采用构造器调用模式，即使用new前缀去调用一个函数时，这将修改函数执行的方式。// 如果new运算符石一个方法而不是一个运算符，它可能会想这样执行Function.method('new', function() &#123; // 创建一个新对象，它继承自构造器函数的原型对象 const that = Object.beget(this.prototype); // 调用构造器函数，绑定到-this-到新对象上 const other = this.apply(that, arguments); // 如果它的返回值不是一个对象就返回该新对象 return (typeof other === 'object' &amp;&amp; other) || that;&#125;);// 定义一个构造器并扩充它的原型const Mammal = function(name) &#123; this.name = name;&#125;;Mammal.prototype.get_name = function() &#123; return this.name;&#125;;Mammal.prototype.says = function() &#123; return this.saying || '';&#125;;// 现在，可以构造一个实例const myMammal = new Mammal('Herb the Mammal');const name = myMammal.get_name();console.log('name', name);// 我们可以构造另一个味蕾来继承Mammal，这是通过定义它的constructor函数// 并替换它的prototype为一个Mammal的实例来实现的const Cat = function(name) &#123; this.name = name; this.saying = 'meow';&#125;;// 替换Cat.prototype为一个新的Mammal实例Cat.prototype = new Mammal();// 扩充新原型对象，增加purr和get_name方法Cat.prototype.purr = function(n) &#123; let i; let s = ''; for (i = 0; i &lt; n; i += 1) &#123; if (s) &#123; s += 'r'; &#125; s += 'r'; &#125; return s;&#125;;Cat.prototype.get_name = function() &#123; return `$&#123;this.says()&#125; $&#123;this.name&#125; $&#123;this.says()&#125;`;&#125;;const myCat = new Cat('Henrietta');const says = myCat.says();console.log('says', says);const purr = myCat.purr('5');console.log('purr', purr);const name1 = myCat.get_name();console.log('name1', name1);// 伪类模式本意是想向面向对象靠拢，但它看起来格格不入。// 我们可以隐藏一些丑陋的细节。// 这是通过使用method方法定义一个inherits方法来实现的Function.method('inherits', function(Parent) &#123; this.prototype = new Parent(); return this;&#125;);// 这样inherits和method方法都返回this，这将允许我们可以以// 级联的样式变成。现在用遗憾语句构造我们的Mouselet Mouse = function(name) &#123; this.name = name; this.saying = 'meow';&#125;.inherits(Mammal) .method('purr', (n) =&gt; &#123; let i; let s = ''; for (i = 0; i &lt; n; i += 1) &#123; if (s) &#123; s += 'r'; &#125; s += 'r'; &#125; return s; &#125;).method('get_name', function() &#123; return `$&#123;this.says()&#125; $&#123;this.name&#125; $&#123;this.says()&#125;`; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/** * 组合模式（Composite）：又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。 * 组合模式使得用户对单个对象和组合对象的使用具有一致性。 */// 原型式继承function inheritObject(o) &#123; // 声明一个过渡函数对象 function F() &#123;&#125; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的一个实例，该实例的原型继承了父对象 return new F();&#125;const inheritPrototype = function(subClass, superClass) &#123; // 复制一份父类的原型副本保存在变量中 const p = inheritObject(superClass.prototype); // 修正因为重写子类原型导致子类的constructor属性被修改 p.constructor = subClass; subClass.prototype = p;&#125;;// 每个成员都要有祖先const News = function() &#123; // 子组件容器 this.children = []; // 当前组件元素 this.element = null;&#125;;News.prototype = &#123; init: () =&gt; &#123; throw new Error('请重写你的方法'); &#125;, add: () =&gt; &#123; throw new Error('请重写你的方法'); &#125;, getElement: () =&gt; &#123; throw new Error('请重写你的方法'); &#125;&#125;;// 容器类构造函数const Container = function(id, parent) &#123; // 构造函数继承父类 News.call(this); // 模块id this.id = id; // 模块的父容器 this.parent = parent; // 构建方法 this.init();&#125;;// 寄生式继承父类原型方法inheritPrototype(Container, News);// 构建方法Container.prototype.init = function() &#123; this.element = document.createElement('ul'); this.element.id = this.id; this.element.className = 'new-container';&#125;;// 添加子元素方法Container.prototype.add = function(child) &#123; // 在子元素容器中插入子元素 this.children.push(child); // 插入当前组件元素树中 this.element.appendChild(child.getElement()); return this;&#125;;// 获取当前元素方法Container.prototype.getElement = function() &#123; return this.element;&#125;;// 显示方法Container.prototype.show = function() &#123; this.parent.appendChild(this.element);&#125;;// 同样的，下一层级的行成员集合类以及后面的新闻组合体类实现的方法与之类似/** * * @param &#123;String&#125; classname 类名 */const Item = function(classname = '') &#123; News.call(this); this.classname = classname; this.init();&#125;;inheritPrototype(Item, News);Item.prototype.init = function() &#123; this.element = document.createElement('li'); this.element.className = this.classname;&#125;;Item.prototype.add = function(child) &#123; // 在子元素容器中插入元素 this.children.push(child); // 插入当前组件元素树中 this.element.appendChild(child.getElement()); return this;&#125;;Item.prototype.getElement = function() &#123; return this.element;&#125;;/** * * @param &#123;String&#125; classname 类名 */const NewsGroup = function(classname = '') &#123; News.call(this); this.classname = classname; this.init();&#125;;inheritPrototype(NewsGroup, News);NewsGroup.prototype.init = function() &#123; this.element = document.createElement('div'); this.element.className = this.classname;&#125;;NewsGroup.prototype.add = function(child) &#123; // 在子元素中插入子元素 this.children.push(child); // 插入当前组件元素树中 this.element.appendChild(child.getElement()); return this;&#125;;NewsGroup.prototype.getElement = function() &#123; return this.element;&#125;;// 创建一个新闻类/** * 需要更底层的新闻类，但是注意这些新闻成员类是不能拥有子成员的，但是他们继承了 * 父类，所有对于add方法最好声明一下，比如创建图片新闻类 */const ImageNews = function(&#123; url = '', href = '#', classname = 'normal' &#125;) &#123; News.call(this); this.url = url; this.href = href; this.classname = classname; this.init();&#125;;inheritPrototype(ImageNews, News);ImageNews.prototype.init = function() &#123; this.element = document.createElement('a'); const img = new Image(); img.src = this.url; this.element.appendChild(img); this.element.className = `image-news $&#123;this.classname&#125;`; this.element.href = this.href;&#125;;ImageNews.prototype.add = function() &#123;&#125;;ImageNews.prototype.getElement = function() &#123; return this.element;&#125;;/** * 新闻类 * @param &#123;Object&#125; &#123; text, href, type &#125; */const IconNews = function(&#123; text = '', href = '#', type = 'video' &#125;) &#123; News.call(this); this.text = text; this.href = href; this.type = type; this.init();&#125;;inheritPrototype(IconNews, News);IconNews.prototype.init = function() &#123; this.element = document.createElement('a'); this.element.innerHTML = this.text; this.element.href = this.href; this.element.className = `icon $&#123;this.type&#125;`;&#125;;IconNews.prototype.add = function() &#123;&#125;;IconNews.prototype.getElement = function() &#123; console.log(this.element); return this.element;&#125;;/** * * @param &#123;Object&#125; &#123; text, href &#125; */const EasyNews = function(&#123; text = '', href = '#' &#125;) &#123; News.call(this); this.text = text; this.href = href; this.init();&#125;;inheritPrototype(EasyNews, News);EasyNews.prototype.init = function() &#123; this.element = document.createElement('a'); this.element.innerHTML = this.text; this.element.href = this.href; this.element.className = 'text';&#125;;EasyNews.prototype.add = function() &#123;&#125;;EasyNews.prototype.getElement = function() &#123; return this.element;&#125;;/** * * @param &#123;Object&#125; &#123; text, href, type, pos &#125; */const TypeNews = function(&#123; text = '', href = '#', type = '', pos = 'left' &#125;) &#123; News.call(this); this.text = text; this.href = href; this.type = type; this.pos = pos; this.init();&#125;;inheritPrototype(TypeNews, News);TypeNews.prototype.init = function() &#123; this.element = document.createElement('a'); if (this.pos === 'left') &#123; this.element.innerHTML = `[$&#123;this.type&#125;] $&#123;this.text&#125;`; &#125; else &#123; this.element.innerHTML = `$&#123;this.text&#125; [$&#123;this.type&#125;]`; &#125; this.element.href = this.href; this.element.className = 'text';&#125;;TypeNews.prototype.add = function() &#123;&#125;;TypeNews.prototype.getElement = function() &#123; return this.element;&#125;;// 创建新闻模块const news = new Container('news', document.body);try &#123; news.add( new Item('normal').add( new IconNews(&#123; text: '梅西不拿金球也伟大', href: '#', type: 'video' &#125;) ) ).add( new Item('normal').add( new NewsGroup('has-img').add( new ImageNews(&#123; url: 'https://gw.alipayobjects.com/zos/rmsportal/BiazfanxmamNRoxxVxka.png', classname: 'small' &#125;) ).add( new EasyNews(&#123; text: '从240斤胖子成功变型男' &#125;) ).add( new EasyNews(&#123; text: '五大雷人跑步机' &#125;) ) ) ).add( new Item('normal').add( new TypeNews(&#123; text: 'AK47不愿为费城打球', type: 'NBA', pos: 'left' &#125;) ) ).add( new Item('normal').add( new TypeNews(&#123; text: '火炮飙6三分创新高', type: 'CBA', pos: 'right' &#125;) ) ).show();&#125; catch (error) &#123; console.log(error.stack || error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 享元模式（FlyWeight）：运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销 */// 错误的代码示范// let article = [];// let dom = null;// let paper = 0;// let num = 5;// let i = 0;// let len = (article || []).length;// for (;i &lt; len; i += 1) &#123;// dom = document.createElement('div');// dom.innerHTML = article[i];// if (i &gt;= num) &#123;// dom.style.display = 'none';// &#125;// document.getElementById('container').appendChild(dom);// &#125;// document.getElementById('next_page').onclick = function() &#123;// const div = document.getElementById('container').getElementsByTagName('div');// let j = 0;// let k = 0;// let n = 0;// for (;j &lt; len; j += 1) &#123;// div[j].style.display = 'none';// &#125;// for (;k &lt; 5; k += 1) &#123;// if (div[n + k]) &#123;// div[n + k].style.display = 'block';// &#125;// &#125;// &#125;;// 享元对象const FlyWeight = function() &#123; // 已创建的元素 const created = []; // 创建一个新闻包装容器 function create() &#123; const dom = document.createElement('div'); // 将容器插入新闻列表容器中 document.getElementById('container').appendChild(dom); // 缓存新创建的元素 created.push(dom); return dom; &#125; return &#123; // 获取创建新闻元素方法 getDiv: function() &#123; // 如果已创建的元素小于当前页元素总个数，则创建 if (created.length &lt; 5) &#123; return create(); &#125; // 获取第一个元素并插入最后面 const div = created.shift(); created.push(div); return div; &#125; &#125;;&#125;;let article = [];let dom = null;let paper = 0;let num = 5;let len = (article || []).length;for (let i = 0; i &lt; num; i += 1) &#123; if (article[i]) &#123; // 通过享元类创建获取的元素并写入新闻内容 FlyWeight.getDiv().innerHTML = article[i]; &#125;&#125;document.getElementById('next_page').onclick = function() &#123; const div = document.getElementById('container').getElementsByTagName('div'); let j = 0; let k = 0; let n = 0; for (;j &lt; len; j += 1) &#123; div[j].style.display = 'none'; &#125; for (;k &lt; 5; k += 1) &#123; if (div[n + k]) &#123; div[n + k].style.display = 'block'; &#125; &#125;&#125;;// 现在生成新闻界面就简单了// 下一页按钮绑定事件document.getElementById('next_page').onclick = function() &#123; // 如果新闻内容不足5条则返回 if (article.length &lt; 5) &#123; return; &#125; let n = ++paper * num % len; // 获取当前页的第一条新闻索引 let j = 0; // 插入5条新闻 for (;j &lt; 5; j += 1) &#123; // 如果存在n + j 条则插入 if (article[n + j]) &#123; FlyWeight.getDiv().innerHTML = article[n + j]; // 否则插入其实位置第 n + j - len 条 &#125; else if (article[n + j - len]) &#123; FlyWeight.getDiv().innerHTML = article[n + j - len]; &#125; else &#123; FlyWeight.getDiv().innerHTML = ''; &#125; &#125;&#125;;// 享元动作const FlyWeight2 = &#123; moveX: function(x) &#123; this.x = x; &#125;, moveY: function(y) &#123; this.y = y; &#125;&#125;;// 其他任何角色都可以通过继承的方式来实现这些方法，比如让人继承移动方法const Player = function(&#123; x, y, color &#125;) &#123; this.x = x; this.y = y; this.color = color;&#125;;Player.prototype = FlyWeight2;Player.prototype.changeC = function(c) &#123; this.color = c;&#125;;// 让精灵继承移动的方法const Spirit = function(&#123; x, y, r &#125;) &#123; this.x = x; this.y = y; this.r = r;&#125;;Spirit.prototype = FlyWeight2;Spirit.prototype.changeR = function(r) &#123; this.r = r;&#125;; 本文所有相关内容均来自于张容铭作者的Javascript设计模式，只供学习所用，切勿转载。如有侵权，请联系我，我会立即删除","categories":[],"tags":[{"name":"javascript design","slug":"javascript-design","permalink":"http://blog.xutengfeng.com/tags/javascript-design/"}]},{"title":"test","slug":"test","date":"2017-11-26T11:15:14.000Z","updated":"2018-07-10T03:35:15.000Z","comments":true,"path":"2017/11/26/test/","link":"","permalink":"http://blog.xutengfeng.com/2017/11/26/test/","excerpt":"","text":"haha","categories":[{"name":"编程","slug":"programming","permalink":"http://blog.xutengfeng.com/categories/programming/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://blog.xutengfeng.com/tags/测试/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-26T08:43:51.132Z","updated":"2018-07-10T03:35:19.000Z","comments":true,"path":"2017/11/26/hello-world/","link":"","permalink":"http://blog.xutengfeng.com/2017/11/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}